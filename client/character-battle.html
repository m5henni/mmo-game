<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Character Battle</title>
<style>
  body {font-family: Arial; background-color: #222; color: #fff; text-align:center;}
  canvas {background-color:#333; display:block; margin:0 auto;}
</style>
</head>
<body>
<h1>Character Battle</h1>
<canvas id="game" width="500" height="500"></canvas>
<script>
const canvas=document.getElementById('game');
const ctx=canvas.getContext('2d');
const gridSize=10;
const cellSize=50;

class Unit {
  constructor(label,row,col,hp,attack,range,color) {
    this.label=label;
    this.row=row;
    this.col=col;
    this.hp=hp;
    this.maxHp=hp;
    this.attack=attack;
    this.range=range;
    this.color=color;
  }
  center() {
    return {x:this.col*cellSize+cellSize/2, y:this.row*cellSize+cellSize/2};
  }
}

const players=[
  new Unit('Tank',8,1,40,3,1,'#2196f3'),
  new Unit('Archer',8,3,25,4,3,'#4caf50'),
  new Unit('Fighter',8,5,30,5,1,'#ff9800')
];
const enemies=[
  new Unit('Enemy',0,8,20,3,1,'#e53935'),
  new Unit('Enemy',2,9,20,3,1,'#e53935'),
  new Unit('Enemy',0,5,20,3,1,'#e53935'),
  new Unit('Enemy',1,7,20,3,1,'#e53935')
];
let selected=null;
let attackEffect=null;

function drawGrid(){
  ctx.strokeStyle='#555';
  for(let i=0;i<=gridSize;i++){
    ctx.beginPath();
    ctx.moveTo(0,i*cellSize);
    ctx.lineTo(gridSize*cellSize,i*cellSize);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(i*cellSize,0);
    ctx.lineTo(i*cellSize,gridSize*cellSize);
    ctx.stroke();
  }
}

function drawUnit(unit, highlight=false){
  const {x,y}=unit.center();
  // draw humanoid
  ctx.save();
  ctx.translate(x, y);
  // head
  ctx.fillStyle=unit.color;
  ctx.beginPath();
  ctx.arc(0,-10,8,0,Math.PI*2);
  ctx.fill();
  // body
  ctx.strokeStyle=unit.color;
  ctx.lineWidth=3;
  ctx.beginPath();
  ctx.moveTo(0,-2);
  ctx.lineTo(0,12);
  ctx.stroke();
  // arms
  ctx.beginPath();
  ctx.moveTo(0,2);
  ctx.lineTo(-8,8);
  ctx.moveTo(0,2);
  ctx.lineTo(8,8);
  ctx.stroke();
  // legs
  ctx.beginPath();
  ctx.moveTo(0,12);
  ctx.lineTo(-6,20);
  ctx.moveTo(0,12);
  ctx.lineTo(6,20);
  ctx.stroke();
  ctx.restore();
  // hp bar
  const barWidth=cellSize*0.8;
  const barX=unit.col*cellSize+cellSize*0.1;
  const barY=unit.row*cellSize+cellSize-6;
  ctx.fillStyle='#444';
  ctx.fillRect(barX,barY,barWidth,4);
  ctx.fillStyle= unit.color;
  ctx.fillRect(barX,barY, barWidth * (unit.hp/unit.maxHp), 4);
  // label
  ctx.fillStyle='#fff';
  ctx.font='10px sans-serif';
  ctx.textAlign='center';
  ctx.fillText(unit.label, unit.col*cellSize+cellSize/2, unit.row*cellSize+10);
  // highlight
  if(highlight) {
    ctx.strokeStyle='#ffeb3b';
    ctx.lineWidth=2;
    ctx.strokeRect(unit.col*cellSize+1, unit.row*cellSize+1, cellSize-2, cellSize-2);
  }
}

function distance(a,b) {
  const dr=a.row-b.row;
  const dc=a.col-b.col;
  return Math.max(Math.abs(dr), Math.abs(dc));
}

function render() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawGrid();
  // draw attack line
  if(attackEffect) {
    const now=performance.now();
    if(now < attackEffect.endTime) {
      ctx.strokeStyle='yellow';
      ctx.lineWidth=3;
      ctx.beginPath();
      ctx.moveTo(attackEffect.from.x, attackEffect.from.y);
      ctx.lineTo(attackEffect.to.x, attackEffect.to.y);
      ctx.stroke();
    } else {
      attackEffect=null;
    }
  }
  players.forEach(p => drawUnit(p, p===selected));
  enemies.forEach(e => drawUnit(e));
  requestAnimationFrame(render);
}
render();

function handleClick(e){
  const rect = canvas.getBoundingClientRect();
  const x=e.clientX-rect.left;
  const y=e.clientY-rect.top;
  const row=Math.floor(y/cellSize);
  const col=Math.floor(x/cellSize);
  const clickedPlayer=players.find(p => p.row===row && p.col===col);
  if(clickedPlayer){
    selected=clickedPlayer;
    return;
  }
  if(!selected) return;
  const target=enemies.find(en => en.row===row && en.col===col);
  if(target && distance(selected, target) <= selected.range) {
    target.hp -= selected.attack;
    attackEffect = { from: selected.center(), to: target.center(), endTime: performance.now()+200 };
    if(target.hp <=0) {
      const idx = enemies.indexOf(target);
      enemies.splice(idx,1);
    }
    enemyTurn();
    return;
  }
  // move
  if(Math.abs(row-selected.row)+Math.abs(col-selected.col) ===1) {
    const occupied = players.concat(enemies).some(u => u.row===row && u.col===col);
    if(!occupied && row>=0 && row<gridSize && col>=0 && col<gridSize) {
      selected.row=row; selected.col=col;
      enemyTurn();
    }
  }
}

function enemyTurn(){
  enemies.forEach(enemy => {
    // find nearest player
    let nearest=null; let minDist=Infinity;
    players.forEach(p => {
      const d=distance(enemy, p);
      if(d<minDist) {minDist=d; nearest=p;}
    });
    if(!nearest) return;
    if(minDist <= enemy.range) {
      nearest.hp -= enemy.attack;
      attackEffect = { from: enemy.center(), to: nearest.center(), endTime: performance.now()+200 };
      if(nearest.hp<=0){
        const idx=players.indexOf(nearest);
        players.splice(idx,1);
        if(selected===nearest) selected=null;
      }
    } else {
      const dr = nearest.row > enemy.row ? 1 : nearest.row < enemy.row ? -1 : 0;
      const dc = nearest.col > enemy.col ? 1 : nearest.col < enemy.col ? -1 : 0;
      const newRow = enemy.row + dr;
      const newCol = enemy.col + dc;
      const occupied = players.some(p => p.row === newRow && p.col===newCol) || enemies.some(e => e !== enemy && e.row===newRow && e.col===newCol);
      if(!occupied && newRow>=0 && newRow<gridSize && newCol>=0 && newCol<gridSize) {
        enemy.row = newRow;
        enemy.col = newCol;
      }
    }
  });
}

canvas.addEventListener('click', handleClick);
</script>
</body>
</html>
